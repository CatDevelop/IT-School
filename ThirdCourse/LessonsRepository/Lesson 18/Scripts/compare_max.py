# Программа засекает время работы собственноручного алгоритма поиска максимума
# для сравнения со временем работы стандартной функции max()
# Проблема: 
# - алгоритм сортировки в выражении lst.index(max(lst[:i])) делает два прохода 
#   по списку (сложность 2*N) + копирование части списка с помощью среза, итого 3*N
# - будет ли алгоритм сортировки более эффективным, если поиск максимума, 
#   включая индекс максимального элемента, делать самостоятельно за один проход?
# Нужно:
# 1) Определить что работает быстрее - стандартная функция max() или реализованный здесь 
#    пользовательский алгоритм поиска максимума
# 2) Доработать приведенный здесь алгоритм поиска максимума таким образом,
#    чтобы он сохранял еще индекс максимального элемента
# 3) Что будет быстрее - алгоритм из пункта 2 или поиск индекса максимального 
#    значения вот этим выражением: max_idx = lst.index(max(lst[:LST_LEN]))
#    ???

from random import randrange
from time import time

# Длина списка, который наполняется случайными числами.
# В этом списке затем ищется максимум
LST_LEN = 1_000_000

# генерация списка для сортировки
lst = [randrange(1000) for i in range(LST_LEN)]

# запомнили время начала поиска максимума
start = time()

# собственный алгоритм поиска максимума в списке
my_max = lst[0]
for item in lst:
    if my_max < item:
        my_max = item

# стандартная альтернатива
#max(lst)

# смотрим сколько времени это заняло
print("Длина списка:", LST_LEN)
print("Поиск максимума занял в секундах", time() - start)

input("\n\nДля выхода нажмите Enter.")
